<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Study App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 600px;
        }

        .auth-card, .home-card, .flashcard-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2.5em;
        }

        h2 {
            color: #555;
            margin-bottom: 20px;
            text-align: center;
        }

        .input-group {
            margin-bottom: 20px;
        }

        input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .user-info {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
        }

        .set-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .flashcard {
            background: white;
            border-radius: 15px;
            padding: 40px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 1.4em;
            line-height: 1.6;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .flashcard-back {
            transform: rotateY(180deg);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
        }

        .answer-section {
            margin-top: 20px;
        }

        .answer-section input {
            margin-bottom: 15px;
        }

        .feedback {
            margin-top: 20px;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-weight: 600;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .feedback.correct {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .feedback.incorrect {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .feedback.partial {
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
            color: white;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .stats {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .stats h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-toggle .btn {
            flex: 1;
            margin-bottom: 0;
            padding: 10px;
            font-size: 14px;
        }

        .mode-toggle .btn.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .hidden {
            display: none;
        }

        .logout-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            font-size: 14px;
            width: auto;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Auth Screen -->
        <div id="authScreen" class="auth-card">
            <h1>ðŸ“š Flashcard Study</h1>
            <div class="input-group">
                <input type="text" id="username" placeholder="Enter username" />
            </div>
            <div class="input-group">
                <input type="password" id="password" placeholder="Enter password" />
            </div>
            <button class="btn" onclick="handleAuth()">Login / Sign Up</button>
            <div id="authMessage" style="color: red; text-align: center; margin-top: 10px;"></div>
        </div>

        <!-- Home Screen -->
        <div id="homeScreen" class="home-card hidden">
            <button class="logout-btn btn" onclick="logout()">Logout</button>
            <h1>ðŸ“š Choose Your Set</h1>
            <div class="user-info">
                <h2 id="welcomeMessage">Welcome!</h2>
                <div id="overallStats"></div>
            </div>
            <div class="set-buttons">
                <button class="btn" onclick="startSet('chain')">Before/After</button>
                <button class="btn btn-secondary" onclick="startSet('chapters')">Chapters</button>
            </div>
        </div>

        <!-- Flashcard Screen -->
        <div id="flashcardScreen" class="flashcard-container hidden">
            <button class="logout-btn btn" onclick="backToHome()">Back to Sets</button>
            <h2 id="setTitle">Set Title</h2>
            
            <div class="stats">
                <h3>Progress</h3>
                <div id="progressStats">Card 1 of 10 | Correct: 0 | Score: 0%</div>
            </div>

            <div class="mode-toggle">
                <button class="btn active" id="randomMode" onclick="setMode('random')">Random</button>
                <button class="btn" id="sequentialMode" onclick="setMode('sequential')">Sequential</button>
            </div>

            <div class="flashcard" id="flashcard" onclick="flipCard()">
                <div class="flashcard-front" id="cardFront">
                    Click to see answer
                </div>
                <div class="flashcard-back" id="cardBack">
                    Back of card
                </div>
            </div>

            <div class="answer-section">
                <!-- Default single input for most sets -->
                <div id="singleAnswerInput">
                    <input type="text" id="userAnswer" placeholder="Type your answer here..." onkeypress="handleAnswerKeypress(event)" />
                    <button class="btn btn-success" onclick="handleAnswerOrNext()">Check Answer</button>
                </div>
                
                <!-- Chain set specific UI with before/after inputs -->
                <div id="chainAnswerInputs" class="hidden">
                    <div class="input-group">
                        <input type="text" id="beforeAnswer" placeholder="Before..." onkeypress="handleChainKeypress(event)" />
                    </div>
                    <div class="input-group">
                        <input type="text" id="afterAnswer" placeholder="After..." onkeypress="handleChainKeypress(event)" />
                    </div>
                    <button class="btn btn-success" onclick="handleChainAnswerOrNext()">Check Answer</button>
                </div>
                
                <div id="feedback" class="feedback hidden"></div>
            </div>
        </div>
    </div>

    <!-- Supabase CDN -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <script>
        // Configuration - using secure local API
        const API_BASE_URL = '/api';
        let authToken = localStorage.getItem('authToken');
        
        // No direct Supabase access - everything goes through secure server
        let supabase = null;
        
        // Flashcard data - will be loaded from database
        let flashcardData = {
            chain: [],
            chapters: []
        };

        // App state
        let currentUser = null;
        let currentSet = null;
        let currentCardIndex = 0;
        let currentCards = [];
        let cardOrder = [];
        let isFlipped = false;
        let mode = 'random';
        let currentSessionId = null;
        let sessionStats = {
            seen: new Set(),
            correct: new Set(),
            wrong: new Set()
        };

        // Secure API client class
        class Database {
            constructor() {
                this.initialized = false;
                this.init();
            }

            async init() {
                try {
                    console.log('Initializing secure API connection...');
                    await this.loadFlashcards();
                    this.initialized = true;
                    console.log('API initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize API:', error);
                    throw error;
                }
            }

            async loadFlashcards() {
                try {
                    const response = await fetch(`${API_BASE_URL}/flashcards`, {
                        headers: authToken ? { 'Authorization': `Bearer ${authToken}` } : {}
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to load flashcards');
                    }
                    
                    flashcardData = await response.json();
                    console.log(`Chain: ${flashcardData.chain.length} cards, Chapters: ${flashcardData.chapters.length} cards`);
                } catch (error) {
                    console.error('Error loading flashcards:', error);
                    throw error;
                }
            }

            async signUp(username, password) {
                const response = await fetch(`${API_BASE_URL}/auth/signup`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Signup failed');
                }
                
                if (data.token) {
                    authToken = data.token;
                    localStorage.setItem('authToken', authToken);
                }
                
                return data;
            }

            async signIn(username, password) {
                const response = await fetch(`${API_BASE_URL}/auth/signin`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error || 'Signin failed');
                }
                
                if (data.token) {
                    authToken = data.token;
                    localStorage.setItem('authToken', authToken);
                }
                
                return data;
            }

            async signOut() {
                try {
                    if (authToken) {
                        await fetch(`${API_BASE_URL}/auth/signout`, {
                            method: 'POST',
                            headers: { 'Authorization': `Bearer ${authToken}` }
                        });
                    }
                } catch (error) {
                    console.error('Signout error:', error);
                }
                
                authToken = null;
                localStorage.removeItem('authToken');
            }

            async getCurrentUser() {
                return authToken ? { id: 'current_user' } : null;
            }

            async getUserProgress() {
                if (!authToken) return {};

                try {
                    const response = await fetch(`${API_BASE_URL}/progress`, {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to fetch progress');
                    }
                    
                    return await response.json();
                } catch (error) {
                    console.error('Error fetching user progress:', error);
                    return {};
                }
            }

            async createStudySession(setId) {
                if (!authToken) return null;
                return 'session_' + Date.now(); // Simple session ID for now
            }

            async updateStudySession(sessionId, stats) {
                // Session tracking handled server-side in save progress
            }

            async saveUserProgress(setId, stats) {
                if (!authToken) {
                    console.error('No authenticated user found');
                    return;
                }

                try {
                    const response = await fetch(`${API_BASE_URL}/progress`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            setId,
                            stats: {
                                seen: Array.from(stats.seen),
                                correct: Array.from(stats.correct)
                            }
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error('Failed to save progress');
                    }
                    
                    console.log('Progress saved successfully');
                } catch (error) {
                    console.error('Error saving user progress:', error);
                }
            }
        }

        const db = new Database();

        // Auth functions
        async function handleAuth() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const authMessage = document.getElementById('authMessage');

            if (!username || !password) {
                authMessage.textContent = 'Please enter both username and password';
                return;
            }

            if (password.length < 6) {
                authMessage.textContent = 'Password must be at least 6 characters';
                return;
            }

            try {
                console.log(`Attempting authentication for: ${username}`);
                authMessage.textContent = 'Authenticating...';
                
                // First try to sign in
                try {
                    const signInResult = await db.signIn(username, password);
                    console.log('Sign in successful:', signInResult);
                    currentUser = username;
                    authMessage.textContent = 'Logged in successfully!';
                    
                    setTimeout(async () => {
                        authMessage.textContent = '';
                        await showHome();
                    }, 1000);
                } catch (signInError) {
                    console.log('Sign in failed:', signInError.message);
                    
                    // Only try to sign up if the error indicates user doesn't exist
                    if (signInError.message.includes('Invalid credentials') || 
                        signInError.message.includes('Signin failed')) {
                        console.log('User might not exist, trying to sign up...');
                        
                        try {
                            const signUpResult = await db.signUp(username, password);
                            console.log('Sign up successful:', signUpResult);
                            currentUser = username;
                            authMessage.textContent = 'Account created successfully!';
                            
                            setTimeout(async () => {
                                authMessage.textContent = '';
                                await showHome();
                            }, 1500);
                        } catch (signUpError) {
                            console.error('Sign up failed:', signUpError);
                            if (signUpError.message.includes('Username already exists')) {
                                authMessage.textContent = 'Account exists but password is incorrect. Please check your password.';
                            } else {
                                authMessage.textContent = 'Error: ' + signUpError.message;
                            }
                        }
                    } else {
                        // For other errors, don't try signup
                        authMessage.textContent = 'Login failed: ' + signInError.message;
                    }
                }
            } catch (error) {
                console.error('Auth error:', error);
                authMessage.textContent = 'Authentication error. Please try again.';
            }
        }

        async function logout() {
            try {
                await db.signOut();
            } catch (error) {
                console.error('Logout error:', error);
            }
            currentUser = null;
            currentSet = null;
            document.getElementById('username').value = '';
            document.getElementById('password').value = '';
            document.getElementById('authScreen').classList.remove('hidden');
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('flashcardScreen').classList.add('hidden');
        }

        async function showHome() {
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('homeScreen').classList.remove('hidden');
            document.getElementById('flashcardScreen').classList.add('hidden');
            document.getElementById('welcomeMessage').textContent = `Welcome, ${currentUser}!`;
            
            // Show overall stats
            try {
                const progress = await db.getUserProgress();
                let statsHTML = '';
                if (progress.chain && flashcardData.chain.length > 0) {
                    const chainScore = Math.round((progress.chain.correct.length / flashcardData.chain.length) * 100);
                    statsHTML += `<div>Chain: ${progress.chain.correct.length}/${flashcardData.chain.length} correct (${chainScore}%)</div>`;
                }
                if (progress.chapters && flashcardData.chapters.length > 0) {
                    const chaptersScore = Math.round((progress.chapters.correct.length / flashcardData.chapters.length) * 100);
                    statsHTML += `<div>Chapters: ${progress.chapters.correct.length}/${flashcardData.chapters.length} correct (${chaptersScore}%)</div>`;
                }
                document.getElementById('overallStats').innerHTML = statsHTML || '<div>No progress yet - start studying!</div>';
            } catch (error) {
                console.error('Error loading progress:', error);
                document.getElementById('overallStats').innerHTML = '<div>Error loading progress</div>';
            }
        }

        async function startSet(setId) {
            currentSet = setId;
            currentCards = flashcardData[setId];
            sessionStats = {
                seen: new Set(),
                correct: new Set(),
                wrong: new Set()
            };
            
            // Create a new study session
            currentSessionId = await db.createStudySession(setId);
            
            // Load previous progress
            try {
                const progress = await db.getUserProgress();
                if (progress[setId]) {
                    progress[setId].seen.forEach(i => sessionStats.seen.add(i));
                    progress[setId].correct.forEach(i => sessionStats.correct.add(i));
                }
            } catch (error) {
                console.error('Error loading progress:', error);
            }
            
            document.getElementById('setTitle').textContent = 
                setId === 'chain' ? 'Before/After' : 'Chapters';
            
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('flashcardScreen').classList.remove('hidden');
            
            initializeCardOrder();
            showNextCard();
        }

        async function backToHome() {
            // Save progress and update session before going back
            if (currentSet && currentUser) {
                try {
                    await db.saveUserProgress(currentSet, sessionStats);
                    await db.updateStudySession(currentSessionId, sessionStats);
                } catch (error) {
                    console.error('Error saving progress:', error);
                }
            }
            
            // Reset session
            currentSessionId = null;
            await showHome();
        }

        function initializeCardOrder() {
            cardOrder = Array.from({ length: currentCards.length }, (_, i) => i);
            if (mode === 'random') {
                shuffleArray(cardOrder);
            }
            currentCardIndex = 0;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function setMode(newMode) {
            mode = newMode;
            document.getElementById('randomMode').classList.toggle('active', mode === 'random');
            document.getElementById('sequentialMode').classList.toggle('active', mode === 'sequential');
            initializeCardOrder();
            showNextCard();
        }

        function showNextCard() {
            if (currentCardIndex >= cardOrder.length) {
                currentCardIndex = 0;
                if (mode === 'random') {
                    shuffleArray(cardOrder);
                }
            }
            
            const cardIdx = cardOrder[currentCardIndex];
            const card = currentCards[cardIdx];
            
            document.getElementById('cardFront').textContent = card.front;
            document.getElementById('cardBack').textContent = card.back;
            document.getElementById('flashcard').classList.remove('flipped');
            isFlipped = false;
            
            // Show appropriate input UI based on set type
            if (currentSet === 'chain') {
                document.getElementById('singleAnswerInput').classList.add('hidden');
                document.getElementById('chainAnswerInputs').classList.remove('hidden');
                
                // Clear chain inputs
                document.getElementById('beforeAnswer').value = '';
                document.getElementById('afterAnswer').value = '';
                
                // Focus on first input
                setTimeout(() => {
                    document.getElementById('beforeAnswer').focus();
                }, 100);
            } else {
                document.getElementById('chainAnswerInputs').classList.add('hidden');
                document.getElementById('singleAnswerInput').classList.remove('hidden');
                
                // Clear single input
                document.getElementById('userAnswer').value = '';
                
                // Focus on input
                setTimeout(() => {
                    document.getElementById('userAnswer').focus();
                }, 100);
            }
            
            document.getElementById('feedback').classList.add('hidden');
            
            sessionStats.seen.add(cardIdx);
            updateStats();
            
            // Reset the next card flag and button text
            window.waitingForNextCard = false;
            
            // Reset button text
            if (currentSet === 'chain') {
                document.querySelector('#chainAnswerInputs .btn').textContent = 'Check Answer';
            } else {
                document.querySelector('#singleAnswerInput .btn').textContent = 'Check Answer';
            }
        }

        function flipCard() {
            const flashcard = document.getElementById('flashcard');
            flashcard.classList.toggle('flipped');
            isFlipped = !isFlipped;
        }

        // LLM assessment function
        async function checkAnswer() {
            const userAnswer = document.getElementById('userAnswer').value.trim();
            if (!userAnswer) {
                showFeedback('Please enter an answer!', 'incorrect');
                return;
            }

            const cardIdx = cardOrder[currentCardIndex];
            const card = currentCards[cardIdx];
            const correctAnswer = card.back;
            
            // Show loading state
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.innerHTML = '<div class="loading"></div> Checking your answer...';
            feedbackDiv.className = 'feedback';
            feedbackDiv.classList.remove('hidden');
            
            try {
                let assessment;
                
                // Try to use Supabase Edge Function, fall back to simple assessment
                try {
                    const response = await supabase.functions.invoke('check-answer', {
                        body: {
                            question: card.front,
                            correctAnswer: correctAnswer,
                            userAnswer: userAnswer
                        }
                    });
                    
                    if (response.error) {
                        throw new Error(response.error.message || 'Edge function error');
                    }
                    
                    assessment = response.data;
                } catch (edgeFunctionError) {
                    console.warn('Edge function not available, using simple assessment:', edgeFunctionError.message);
                    assessment = simpleAssessment(userAnswer, correctAnswer);
                }
                
                // Handle the assessment result
                await handleAssessmentResult(assessment, cardIdx);
                
            } catch (error) {
                console.error('Error checking answer:', error);
                // Fallback to simple string comparison
                const assessment = simpleAssessment(userAnswer, correctAnswer);
                await handleAssessmentResult(assessment, cardIdx);
            }
        }

        function simpleAssessment(userAnswer, correctAnswer) {
            const userLower = userAnswer.toLowerCase();
            const correctLower = correctAnswer.toLowerCase();
            
            if (userLower === correctLower || correctLower.includes(userLower) || userLower.includes(correctLower)) {
                return {
                    result: "correct",
                    feedback: "Correct! Well done!"
                };
            } else if (userLower.split(' ').some(word => correctLower.includes(word) && word.length > 3)) {
                return {
                    result: "partial",
                    feedback: "Partially correct. The full answer is: " + correctAnswer
                };
            } else {
                return {
                    result: "incorrect",
                    feedback: "Not quite. The correct answer is: " + correctAnswer
                };
            }
        }

        async function handleAssessmentResult(assessment, cardIdx) {
            // Update stats based on assessment
            if (assessment.result === "correct") {
                sessionStats.correct.add(cardIdx);
                sessionStats.wrong.delete(cardIdx);
            } else if (assessment.result === "partial") {
                // You can decide how to handle partial answers
                // For now, we'll count them as seen but not fully correct
                if (!sessionStats.correct.has(cardIdx)) {
                    sessionStats.wrong.add(cardIdx);
                }
            } else {
                sessionStats.wrong.add(cardIdx);
                sessionStats.correct.delete(cardIdx);
            }
            
            // Show feedback
            showFeedback(assessment.feedback, assessment.result);
            
            // Auto-flip card to show answer
            if (!isFlipped) {
                flipCard();
            }
            
            // Save progress and prepare for next card
            updateStats();
            if (currentCardIndex % 5 === 0 || currentCardIndex >= cardOrder.length) {
                try {
                    await db.saveUserProgress(currentSet, sessionStats);
                    await db.updateStudySession(currentSessionId, sessionStats);
                } catch (error) {
                    console.error('Error saving progress:', error);
                }
            }
            
            // Set flag to wait for user to press Enter
            window.waitingForNextCard = true;
            
            // Update button text to indicate next card
            if (currentSet === 'chain') {
                document.querySelector('#chainAnswerInputs .btn').textContent = 'Next Card';
            } else {
                document.querySelector('#singleAnswerInput .btn').textContent = 'Next Card';
            }
        }

        function showFeedback(message, type) {
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.textContent = message;
            feedbackDiv.className = 'feedback ' + type;
            feedbackDiv.classList.remove('hidden');
        }

        function handleAnswerKeypress(event) {
            if (event.key === 'Enter') {
                if (window.waitingForNextCard) {
                    moveToNextCard();
                } else {
                    checkAnswer();
                }
            }
        }

        function handleChainKeypress(event) {
            if (event.key === 'Enter') {
                if (window.waitingForNextCard) {
                    moveToNextCard();
                } else if (event.target.id === 'beforeAnswer') {
                    // If we're in the before field, move to after field
                    document.getElementById('afterAnswer').focus();
                } else {
                    // If we're in the after field, check answer
                    checkChainAnswer();
                }
            }
        }

        function moveToNextCard() {
            currentCardIndex++;
            showNextCard();
            
            // Clear appropriate inputs based on set type
            if (currentSet === 'chain') {
                document.getElementById('beforeAnswer').value = '';
                document.getElementById('afterAnswer').value = '';
            } else {
                document.getElementById('userAnswer').value = '';
            }
            
            document.getElementById('feedback').classList.add('hidden');
            window.waitingForNextCard = false;
        }

        function handleAnswerOrNext() {
            if (window.waitingForNextCard) {
                moveToNextCard();
            } else {
                checkAnswer();
            }
        }

        function handleChainAnswerOrNext() {
            if (window.waitingForNextCard) {
                moveToNextCard();
            } else {
                checkChainAnswer();
            }
        }

        async function checkChainAnswer() {
            const beforeAnswer = document.getElementById('beforeAnswer').value.trim();
            const afterAnswer = document.getElementById('afterAnswer').value.trim();
            
            if (!beforeAnswer || !afterAnswer) {
                showFeedback('Please fill in both Before and After fields!', 'incorrect');
                return;
            }

            const cardIdx = cardOrder[currentCardIndex];
            const card = currentCards[cardIdx];
            const correctAnswer = card.back;
            
            // Concatenate user answers in the required format
            const userAnswer = `Before: ${beforeAnswer}\nAfter: ${afterAnswer}`;
            
            // Show loading state
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.innerHTML = '<div class="loading"></div> Checking your answer...';
            feedbackDiv.className = 'feedback';
            feedbackDiv.classList.remove('hidden');
            
            try {
                let assessment;
                
                // Try to use Supabase Edge Function, fall back to simple assessment
                try {
                    const response = await supabase.functions.invoke('check-answer', {
                        body: {
                            question: card.front,
                            correctAnswer: correctAnswer,
                            userAnswer: userAnswer
                        }
                    });
                    
                    if (response.error) {
                        throw new Error(response.error.message || 'Edge function error');
                    }
                    
                    assessment = response.data;
                } catch (edgeFunctionError) {
                    console.warn('Edge function not available, using simple assessment:', edgeFunctionError.message);
                    assessment = simpleAssessment(userAnswer, correctAnswer);
                }
                
                // Handle the assessment result
                await handleAssessmentResult(assessment, cardIdx);
                
            } catch (error) {
                console.error('Error checking answer:', error);
                // Fallback to simple string comparison
                const assessment = simpleAssessment(userAnswer, correctAnswer);
                await handleAssessmentResult(assessment, cardIdx);
            }
        }

        async function markCard(correct) {
            // This function is no longer needed but kept for compatibility
            const cardIdx = cardOrder[currentCardIndex];
            
            if (correct) {
                sessionStats.correct.add(cardIdx);
                sessionStats.wrong.delete(cardIdx);
            } else {
                sessionStats.wrong.add(cardIdx);
                sessionStats.correct.delete(cardIdx);
            }
            
            currentCardIndex++;
            
            // Save progress periodically
            if (currentCardIndex % 5 === 0 || currentCardIndex >= cardOrder.length) {
                try {
                    await db.saveUserProgress(currentSet, sessionStats);
                } catch (error) {
                    console.error('Error saving progress:', error);
                }
            }
            
            showNextCard();
        }

        function updateStats() {
            const total = currentCards.length;
            const seen = sessionStats.seen.size;
            const correct = sessionStats.correct.size;
            const score = seen > 0 ? Math.round((correct / seen) * 100) : 0;
            
            document.getElementById('progressStats').textContent = 
                `Cards seen: ${seen}/${total} | Correct: ${correct} | Score: ${score}%`;
        }

        // Enter key support for login
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('password').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleAuth();
                }
            });
        });
    </script>
</body>
</html>