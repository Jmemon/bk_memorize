<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard Study App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            width: 100%;
            max-width: 600px;
        }

        .auth-card, .home-card, .flashcard-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
            font-size: 2.5em;
        }

        h2 {
            color: #555;
            margin-bottom: 20px;
            text-align: center;
        }

        .input-group {
            margin-bottom: 20px;
        }

        input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .user-info {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
        }

        .set-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .flashcard {
            background: white;
            border-radius: 15px;
            padding: 40px;
            min-height: 300px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 1.4em;
            line-height: 1.6;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            position: relative;
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-front, .flashcard-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .flashcard-back {
            transform: rotateY(180deg);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
        }

        .answer-section {
            margin-top: 20px;
        }

        .answer-section input {
            margin-bottom: 15px;
        }

        .feedback {
            margin-top: 20px;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-weight: 600;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .feedback.correct {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .feedback.incorrect {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .feedback.partial {
            background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
            color: white;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .stats {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .stats h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .mode-toggle .btn {
            flex: 1;
            margin-bottom: 0;
            padding: 10px;
            font-size: 14px;
        }

        .mode-toggle .btn.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        .hidden {
            display: none;
        }

        .logout-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            font-size: 14px;
            width: auto;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Auth Screen -->
        <div id="authScreen" class="auth-card">
            <h1>ðŸ“š Flashcard Study</h1>
            <div class="input-group">
                <input type="text" id="username" placeholder="Enter username" />
            </div>
            <div class="input-group">
                <input type="password" id="password" placeholder="Enter password" />
            </div>
            <button class="btn" onclick="handleAuth()">Login / Sign Up</button>
            <div id="authMessage" style="color: red; text-align: center; margin-top: 10px;"></div>
        </div>

        <!-- Home Screen -->
        <div id="homeScreen" class="home-card hidden">
            <button class="logout-btn btn" onclick="logout()">Logout</button>
            <h1>ðŸ“š Choose Your Set</h1>
            <div class="user-info">
                <h2 id="welcomeMessage">Welcome!</h2>
                <div id="overallStats"></div>
            </div>
            <div class="set-buttons">
                <button class="btn" onclick="startSet('chain')">Brothers Karamazov - Chain</button>
                <button class="btn btn-secondary" onclick="startSet('chapters')">Brothers Karamazov - Chapters</button>
            </div>
        </div>

        <!-- Flashcard Screen -->
        <div id="flashcardScreen" class="flashcard-container hidden">
            <button class="logout-btn btn" onclick="backToHome()">Back to Sets</button>
            <h2 id="setTitle">Set Title</h2>
            
            <div class="stats">
                <h3>Progress</h3>
                <div id="progressStats">Card 1 of 10 | Correct: 0 | Score: 0%</div>
            </div>

            <div class="mode-toggle">
                <button class="btn active" id="randomMode" onclick="setMode('random')">Random</button>
                <button class="btn" id="sequentialMode" onclick="setMode('sequential')">Sequential</button>
            </div>

            <div class="flashcard" id="flashcard" onclick="flipCard()">
                <div class="flashcard-front" id="cardFront">
                    Click to see answer
                </div>
                <div class="flashcard-back" id="cardBack">
                    Back of card
                </div>
            </div>

            <div class="answer-section">
                <input type="text" id="userAnswer" placeholder="Type your answer here..." onkeypress="handleAnswerKeypress(event)" />
                <button class="btn btn-success" onclick="checkAnswer()">Check Answer</button>
                <div id="feedback" class="feedback hidden"></div>
            </div>
        </div>
    </div>

    <!-- Supabase CDN -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <script>
        // Configuration - Replace with your actual Supabase URL and key
        const SUPABASE_URL = 'https://jpuwgxqktbifndafoewf.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpwdXdneHFrdGJpZm5kYWZvZXdmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY2ODI2NzksImV4cCI6MjA3MjI1ODY3OX0.DhUiR7m1ANgY9GNVJX9-Xs5aiRCiWH-O0Zsf1WtTS3c';
        
        // Initialize Supabase client
        let supabase = null;
        if (SUPABASE_URL !== 'YOUR_SUPABASE_URL' && SUPABASE_ANON_KEY !== 'YOUR_SUPABASE_ANON_KEY') {
            supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        }
        
        // Flashcard data - will be loaded from database
        let flashcardData = {
            chain: [],
            chapters: []
        };

        // App state
        let currentUser = null;
        let currentSet = null;
        let currentCardIndex = 0;
        let currentCards = [];
        let cardOrder = [];
        let isFlipped = false;
        let mode = 'random';
        let currentSessionId = null;
        let sessionStats = {
            seen: new Set(),
            correct: new Set(),
            wrong: new Set()
        };

        // Database class with Supabase integration and localStorage fallback
        class Database {
            constructor() {
                this.initialized = false;
                this.init();
            }

            async init() {
                if (!supabase) {
                    console.error('No Supabase connection available');
                    throw new Error('No Supabase connection available');
                }

                try {
                    console.log('Initializing database connection...');
                    
                    // Test the connection first
                    const { data, error } = await supabase
                        .from('flashcard_sets')
                        .select('count(*)')
                        .limit(1);
                    
                    if (error) {
                        console.error('Database connection test failed:', error);
                        throw error;
                    }
                    
                    console.log('Database connection successful');
                    
                    await this.loadFlashcards();
                    this.initialized = true;
                    console.log('Database initialized successfully');
                } catch (error) {
                    console.error('Failed to initialize database:', error);
                    throw error;
                }
            }

            async loadFlashcards() {
                try {
                    // Load flashcards from database
                    const { data: cards, error } = await supabase
                        .from('flashcards')
                        .select(`
                            *,
                            flashcard_sets!inner(set_id, set_name)
                        `)
                        .order('card_index');

                    if (error) throw error;

                    if (!cards || cards.length === 0) {
                        throw new Error('No flashcards found in database. Please run the migration to populate flashcard data.');
                    }

                    // Organize cards by set
                    flashcardData = { chain: [], chapters: [] };
                    
                    cards.forEach(card => {
                        const setId = card.flashcard_sets.set_id;
                        if (flashcardData[setId]) {
                            flashcardData[setId].push({
                                front: card.front,
                                back: card.back,
                                index: card.card_index
                            });
                        }
                    });

                    console.log(`Loaded ${cards.length} flashcards from database`);
                    console.log(`Chain: ${flashcardData.chain.length} cards, Chapters: ${flashcardData.chapters.length} cards`);
                } catch (error) {
                    console.error('Error loading flashcards:', error);
                    throw error;
                }
            }

            async signUp(email, password, username) {
                const { data, error } = await supabase.auth.signUp({
                    email: email,
                    password: password,
                    options: {
                        data: {
                            username: username
                        }
                    }
                });
                if (error) throw error;
                
                // Also create entry in custom accounts table
                if (data.user) {
                    await this.createAccountRecord(data.user.id, username, password);
                }
                
                return data;
            }

            async createAccountRecord(userId, username, password) {
                try {
                    // Check if account already exists
                    const { data: existing } = await supabase
                        .from('accounts')
                        .select('id')
                        .eq('id', userId)
                        .single();
                    
                    if (!existing) {
                        const { error } = await supabase
                            .from('accounts')
                            .insert({
                                id: userId,
                                username: username,
                                password_hash: password // In production, this should be hashed
                            });
                        
                        if (error) {
                            console.error('Error creating account record:', error);
                        } else {
                            console.log('Account record created successfully');
                        }
                    }
                } catch (error) {
                    console.error('Error in createAccountRecord:', error);
                }
            }

            async signIn(email, password) {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password
                });
                if (error) throw error;
                
                // Ensure account record exists in custom table
                if (data.user) {
                    const username = data.user.user_metadata?.username || data.user.email.split('@')[0];
                    await this.createAccountRecord(data.user.id, username, password);
                }
                
                return data;
            }

            async signOut() {
                const { error } = await supabase.auth.signOut();
                if (error) throw error;
            }

            async getCurrentUser() {
                const { data: { user }, error } = await supabase.auth.getUser();
                if (error) throw error;
                return user;
            }

            async getUserProgress() {
                const user = await this.getCurrentUser();
                if (!user) return {};

                try {
                    const { data: progress, error } = await supabase
                        .from('user_progress')
                        .select(`
                            *,
                            flashcards!inner(card_index),
                            flashcard_sets!inner(set_id)
                        `)
                        .eq('user_id', user.id);

                    if (error) {
                        console.error('Error fetching user progress:', error);
                        return {};
                    }

                    // Format progress data
                    const formattedProgress = {};
                    progress?.forEach(p => {
                        const setId = p.flashcard_sets.set_id;
                        if (!formattedProgress[setId]) {
                            formattedProgress[setId] = { correct: [], seen: [] };
                        }
                        const cardIndex = p.flashcards.card_index;
                        formattedProgress[setId].seen.push(cardIndex);
                        if (p.is_correct) {
                            formattedProgress[setId].correct.push(cardIndex);
                        }
                    });

                    return formattedProgress;
                } catch (error) {
                    console.error('Unexpected error in getUserProgress:', error);
                    return {};
                }
            }

            async createStudySession(setId) {
                const user = await this.getCurrentUser();
                if (!user) return null;

                try {
                    // Get set UUID
                    const { data: sets, error: setError } = await supabase
                        .from('flashcard_sets')
                        .select('id')
                        .eq('set_id', setId)
                        .single();

                    if (setError || !sets) {
                        console.error(`Set ${setId} not found:`, setError);
                        return null;
                    }

                    const { data, error } = await supabase
                        .from('study_sessions')
                        .insert({
                            user_id: user.id,
                            set_id: sets.id,
                            cards_seen: 0,
                            cards_correct: 0,
                            session_score: 0,
                            started_at: new Date().toISOString()
                        })
                        .select()
                        .single();

                    if (error) {
                        console.error('Error creating study session:', error);
                        return null;
                    }

                    console.log('Study session created:', data.id);
                    return data.id;
                } catch (error) {
                    console.error('Unexpected error creating study session:', error);
                    return null;
                }
            }

            async updateStudySession(sessionId, stats) {
                if (!sessionId) return;

                try {
                    const totalSeen = stats.seen.size;
                    const totalCorrect = stats.correct.size;
                    const score = totalSeen > 0 ? Math.round((totalCorrect / totalSeen) * 100) : 0;

                    const { error } = await supabase
                        .from('study_sessions')
                        .update({
                            cards_seen: totalSeen,
                            cards_correct: totalCorrect,
                            session_score: score,
                            ended_at: new Date().toISOString()
                        })
                        .eq('id', sessionId);

                    if (error) {
                        console.error('Error updating study session:', error);
                    } else {
                        console.log(`Study session updated - seen: ${totalSeen}, correct: ${totalCorrect}, score: ${score}%`);
                    }
                } catch (error) {
                    console.error('Unexpected error updating study session:', error);
                }
            }

            async saveUserProgress(setId, stats) {
                const user = await this.getCurrentUser();
                if (!user) {
                    console.error('No authenticated user found');
                    return;
                }

                try {
                    // Get set UUID
                    const { data: sets, error: setError } = await supabase
                        .from('flashcard_sets')
                        .select('id')
                        .eq('set_id', setId)
                        .single();

                    if (setError || !sets) {
                        console.error(`Set ${setId} not found:`, setError);
                        return;
                    }

                    // Get flashcards for this set
                    const { data: flashcards, error: cardsError } = await supabase
                        .from('flashcards')
                        .select('id, card_index')
                        .eq('set_id', sets.id);

                    if (cardsError) {
                        console.error('Error fetching flashcards:', cardsError);
                        return;
                    }

                    console.log(`Saving progress for user ${user.id}, set ${setId}`);
                    console.log(`Stats - seen: ${stats.seen.size}, correct: ${stats.correct.size}`);

                    // Update progress for each card
                    for (const card of flashcards) {
                        const cardIndex = card.card_index;
                        const isCorrect = stats.correct.has(cardIndex);
                        const wasSeen = stats.seen.has(cardIndex);

                        if (wasSeen) {
                            console.log(`Updating card ${cardIndex}: seen=${wasSeen}, correct=${isCorrect}`);
                            
                            // First try to get existing progress
                            const { data: existingProgress } = await supabase
                                .from('user_progress')
                                .select('times_seen, times_correct')
                                .eq('user_id', user.id)
                                .eq('card_id', card.id)
                                .single();

                            const prevTimesSeen = existingProgress?.times_seen || 0;
                            const prevTimesCorrect = existingProgress?.times_correct || 0;

                            const { error } = await supabase
                                .from('user_progress')
                                .upsert({
                                    user_id: user.id,
                                    set_id: sets.id,
                                    card_id: card.id,
                                    is_correct: isCorrect,
                                    times_seen: prevTimesSeen + 1,
                                    times_correct: prevTimesCorrect + (isCorrect ? 1 : 0),
                                    last_seen: new Date().toISOString()
                                }, {
                                    onConflict: 'user_id,card_id'
                                });
                            
                            if (error) {
                                console.error('Error saving progress for card:', card.card_index, error);
                            } else {
                                console.log(`Successfully saved progress for card ${cardIndex}`);
                            }
                        }
                    }
                } catch (error) {
                    console.error('Unexpected error saving user progress:', error);
                }
            }
        }

        const db = new Database();

        // Auth functions
        async function handleAuth() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const authMessage = document.getElementById('authMessage');

            if (!username || !password) {
                authMessage.textContent = 'Please enter both username and password';
                return;
            }

            if (password.length < 6) {
                authMessage.textContent = 'Password must be at least 6 characters';
                return;
            }

            try {
                // Convert username to email format for Supabase Auth
                const email = username.toLowerCase() + '@flashcards.local';
                
                console.log(`Attempting authentication for: ${email}`);
                authMessage.textContent = 'Authenticating...';
                
                // First try to sign in
                try {
                    const signInResult = await db.signIn(email, password);
                    console.log('Sign in successful:', signInResult);
                    currentUser = username;
                    authMessage.textContent = 'Logged in successfully!';
                    
                    setTimeout(async () => {
                        authMessage.textContent = '';
                        await showHome();
                    }, 1000);
                } catch (signInError) {
                    console.log('Sign in failed, trying to sign up:', signInError.message);
                    
                    // If sign in fails, try to sign up
                    try {
                        const signUpResult = await db.signUp(email, password, username);
                        console.log('Sign up successful:', signUpResult);
                        currentUser = username;
                        authMessage.textContent = 'Account created successfully!';
                        
                        setTimeout(async () => {
                            authMessage.textContent = '';
                            await showHome();
                        }, 1500);
                    } catch (signUpError) {
                        console.error('Sign up failed:', signUpError);
                        authMessage.textContent = 'Error: ' + signUpError.message;
                    }
                }
            } catch (error) {
                console.error('Auth error:', error);
                authMessage.textContent = 'Authentication error. Please try again.';
            }
        }

        async function logout() {
            try {
                await db.signOut();
            } catch (error) {
                console.error('Logout error:', error);
            }
            currentUser = null;
            currentSet = null;
            document.getElementById('username').value = '';
            document.getElementById('password').value = '';
            document.getElementById('authScreen').classList.remove('hidden');
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('flashcardScreen').classList.add('hidden');
        }

        async function showHome() {
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('homeScreen').classList.remove('hidden');
            document.getElementById('flashcardScreen').classList.add('hidden');
            document.getElementById('welcomeMessage').textContent = `Welcome, ${currentUser}!`;
            
            // Show overall stats
            try {
                const progress = await db.getUserProgress();
                let statsHTML = '';
                if (progress.chain && flashcardData.chain.length > 0) {
                    const chainScore = Math.round((progress.chain.correct.length / flashcardData.chain.length) * 100);
                    statsHTML += `<div>Chain: ${progress.chain.correct.length}/${flashcardData.chain.length} correct (${chainScore}%)</div>`;
                }
                if (progress.chapters && flashcardData.chapters.length > 0) {
                    const chaptersScore = Math.round((progress.chapters.correct.length / flashcardData.chapters.length) * 100);
                    statsHTML += `<div>Chapters: ${progress.chapters.correct.length}/${flashcardData.chapters.length} correct (${chaptersScore}%)</div>`;
                }
                document.getElementById('overallStats').innerHTML = statsHTML || '<div>No progress yet - start studying!</div>';
            } catch (error) {
                console.error('Error loading progress:', error);
                document.getElementById('overallStats').innerHTML = '<div>Error loading progress</div>';
            }
        }

        async function startSet(setId) {
            currentSet = setId;
            currentCards = [...flashcardData[setId]];
            sessionStats = {
                seen: new Set(),
                correct: new Set(),
                wrong: new Set()
            };
            
            // Create a new study session
            currentSessionId = await db.createStudySession(setId);
            
            // Load previous progress
            try {
                const progress = await db.getUserProgress();
                if (progress[setId]) {
                    progress[setId].seen.forEach(i => sessionStats.seen.add(i));
                    progress[setId].correct.forEach(i => sessionStats.correct.add(i));
                }
            } catch (error) {
                console.error('Error loading progress:', error);
            }
            
            document.getElementById('setTitle').textContent = 
                setId === 'chain' ? 'Brothers Karamazov - Chain' : 'Brothers Karamazov - Chapters';
            
            document.getElementById('homeScreen').classList.add('hidden');
            document.getElementById('flashcardScreen').classList.remove('hidden');
            
            initializeCardOrder();
            showNextCard();
        }

        async function backToHome() {
            // Save progress and update session before going back
            if (currentSet && currentUser) {
                try {
                    await db.saveUserProgress(currentSet, sessionStats);
                    await db.updateStudySession(currentSessionId, sessionStats);
                } catch (error) {
                    console.error('Error saving progress:', error);
                }
            }
            
            // Reset session
            currentSessionId = null;
            await showHome();
        }

        function initializeCardOrder() {
            cardOrder = Array.from({ length: currentCards.length }, (_, i) => i);
            if (mode === 'random') {
                shuffleArray(cardOrder);
            }
            currentCardIndex = 0;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function setMode(newMode) {
            mode = newMode;
            document.getElementById('randomMode').classList.toggle('active', mode === 'random');
            document.getElementById('sequentialMode').classList.toggle('active', mode === 'sequential');
            initializeCardOrder();
            showNextCard();
        }

        function showNextCard() {
            if (currentCardIndex >= cardOrder.length) {
                currentCardIndex = 0;
                if (mode === 'random') {
                    shuffleArray(cardOrder);
                }
            }
            
            const cardIdx = cardOrder[currentCardIndex];
            const card = currentCards[cardIdx];
            
            document.getElementById('cardFront').textContent = card.front;
            document.getElementById('cardBack').textContent = card.back;
            document.getElementById('flashcard').classList.remove('flipped');
            isFlipped = false;
            
            // Clear previous answer and feedback
            document.getElementById('userAnswer').value = '';
            document.getElementById('feedback').classList.add('hidden');
            
            sessionStats.seen.add(cardIdx);
            updateStats();
            
            // Focus on input for better UX
            setTimeout(() => {
                document.getElementById('userAnswer').focus();
            }, 100);
        }

        function flipCard() {
            const flashcard = document.getElementById('flashcard');
            flashcard.classList.toggle('flipped');
            isFlipped = !isFlipped;
        }

        // LLM assessment function
        async function checkAnswer() {
            const userAnswer = document.getElementById('userAnswer').value.trim();
            if (!userAnswer) {
                showFeedback('Please enter an answer!', 'incorrect');
                return;
            }

            const cardIdx = cardOrder[currentCardIndex];
            const card = currentCards[cardIdx];
            const correctAnswer = card.back;
            
            // Show loading state
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.innerHTML = '<div class="loading"></div> Checking your answer...';
            feedbackDiv.className = 'feedback';
            feedbackDiv.classList.remove('hidden');
            
            try {
                let assessment;
                
                // Try to use Supabase Edge Function, fall back to simple assessment
                try {
                    const response = await supabase.functions.invoke('check-answer', {
                        body: {
                            question: card.front,
                            correctAnswer: correctAnswer,
                            userAnswer: userAnswer
                        }
                    });
                    
                    if (response.error) {
                        throw new Error(response.error.message || 'Edge function error');
                    }
                    
                    assessment = response.data;
                } catch (edgeFunctionError) {
                    console.warn('Edge function not available, using simple assessment:', edgeFunctionError.message);
                    assessment = simpleAssessment(userAnswer, correctAnswer);
                }
                
                // Handle the assessment result
                await handleAssessmentResult(assessment, cardIdx);
                
            } catch (error) {
                console.error('Error checking answer:', error);
                // Fallback to simple string comparison
                const assessment = simpleAssessment(userAnswer, correctAnswer);
                await handleAssessmentResult(assessment, cardIdx);
            }
        }

        function simpleAssessment(userAnswer, correctAnswer) {
            const userLower = userAnswer.toLowerCase();
            const correctLower = correctAnswer.toLowerCase();
            
            if (userLower === correctLower || correctLower.includes(userLower) || userLower.includes(correctLower)) {
                return {
                    result: "correct",
                    feedback: "Correct! Well done!"
                };
            } else if (userLower.split(' ').some(word => correctLower.includes(word) && word.length > 3)) {
                return {
                    result: "partial",
                    feedback: "Partially correct. The full answer is: " + correctAnswer
                };
            } else {
                return {
                    result: "incorrect",
                    feedback: "Not quite. The correct answer is: " + correctAnswer
                };
            }
        }

        async function handleAssessmentResult(assessment, cardIdx) {
            // Update stats based on assessment
            if (assessment.result === "correct") {
                sessionStats.correct.add(cardIdx);
                sessionStats.wrong.delete(cardIdx);
            } else if (assessment.result === "partial") {
                // You can decide how to handle partial answers
                // For now, we'll count them as seen but not fully correct
                if (!sessionStats.correct.has(cardIdx)) {
                    sessionStats.wrong.add(cardIdx);
                }
            } else {
                sessionStats.wrong.add(cardIdx);
                sessionStats.correct.delete(cardIdx);
            }
            
            // Show feedback
            showFeedback(assessment.feedback, assessment.result);
            
            // Auto-flip card to show answer
            if (!isFlipped) {
                flipCard();
            }
            
            // Save progress and prepare for next card
            updateStats();
            if (currentCardIndex % 5 === 0 || currentCardIndex >= cardOrder.length) {
                try {
                    await db.saveUserProgress(currentSet, sessionStats);
                    await db.updateStudySession(currentSessionId, sessionStats);
                } catch (error) {
                    console.error('Error saving progress:', error);
                }
            }
            
            // Move to next card after delay
            setTimeout(() => {
                currentCardIndex++;
                showNextCard();
                document.getElementById('userAnswer').value = '';
                document.getElementById('feedback').classList.add('hidden');
            }, 3000);
        }

        function showFeedback(message, type) {
            const feedbackDiv = document.getElementById('feedback');
            feedbackDiv.textContent = message;
            feedbackDiv.className = 'feedback ' + type;
            feedbackDiv.classList.remove('hidden');
        }

        function handleAnswerKeypress(event) {
            if (event.key === 'Enter') {
                checkAnswer();
            }
        }

        async function markCard(correct) {
            // This function is no longer needed but kept for compatibility
            const cardIdx = cardOrder[currentCardIndex];
            
            if (correct) {
                sessionStats.correct.add(cardIdx);
                sessionStats.wrong.delete(cardIdx);
            } else {
                sessionStats.wrong.add(cardIdx);
                sessionStats.correct.delete(cardIdx);
            }
            
            currentCardIndex++;
            
            // Save progress periodically
            if (currentCardIndex % 5 === 0 || currentCardIndex >= cardOrder.length) {
                try {
                    await db.saveUserProgress(currentSet, sessionStats);
                } catch (error) {
                    console.error('Error saving progress:', error);
                }
            }
            
            showNextCard();
        }

        function updateStats() {
            const total = currentCards.length;
            const seen = sessionStats.seen.size;
            const correct = sessionStats.correct.size;
            const score = seen > 0 ? Math.round((correct / seen) * 100) : 0;
            
            document.getElementById('progressStats').textContent = 
                `Cards seen: ${seen}/${total} | Correct: ${correct} | Score: ${score}%`;
        }

        // Enter key support for login
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('password').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleAuth();
                }
            });
        });
    </script>
</body>
</html>